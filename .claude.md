# Development Preferences

## General Workflow
- **Autonomous iteration**: AI/agents should work on implementation and testing on the target system without requiring user feedback during iterations
- **Minimize feedback rounds**: Try to concentrate all feedback requests to one time per iteration
- Work independently through implementation and testing cycles before presenting results
- **Always ask before pushing to remote repositories** - never push to remote repos without explicit user confirmation
- **Change workflow when receiving user input**:
  1. Update the specification (ask user if new input conflicts with existing spec)
  2. Update the tests based on new requirements
  3. Update the code to match updated tests and spec
  4. Verify implementation against specification and tests
- **Attribution**: Do not mention that code, commits, or other artifacts were created by AI/Claude in commit messages, code comments, or documentation

## Claude Configuration Management
- **Track .claude/ in repo**: All slash commands and directives in `.claude/` should be tracked in this repository
- **Monitor for changes**: Check if files in `~/.claude/commands/` differ from `.claude/commands/` in the repo
- **Suggest updates**: If local `~/.claude/` files have been modified, proactively suggest updating the repo to keep configuration in sync
- **Bidirectional sync**: Changes can flow both ways:
  - Repo → `~/.claude/` when updating local configuration from the repository
  - `~/.claude/` → Repo when local changes should be committed and tracked

## Version Control
- **Always add .gitignore** to every project from the start

## Python Projects
- **Always use `uv`** for Python package management and virtual environments
- Prefer `uv` commands over pip/virtualenv/poetry
- **Use `pyproject.toml`** for project configuration
- **Minimal dependencies as first choice**: Prefer standard library solutions when possible, only add dependencies when they provide significant value
- **Project structure**: Use src/ layout for Python projects with a separate `tests/` directory for all test code

## Software Design
- **Prefer native Debian 13 components** when designing software architecture
- Even when the current development target is macOS, design with Debian 13 native components in mind for portability
- **Cross-platform deployment**: Optimize component selections to deploy on:
  - macOS (ARM/Apple Silicon)
  - Linux (x86-64)
  - Windows (x86-64)
- Choose libraries and dependencies that support all three platforms

## Architecture Principles
- **Strongly prefer layered architecture**: Organize code into distinct layers (presentation, business logic, data access)
- **Separation of concerns**: Each component/module should have a single, well-defined responsibility
- **Loose coupling**: Components should be independent and communicate through well-defined interfaces
- **High cohesion**: Related functionality should be grouped together
- **Dependency injection**: Use DI patterns to improve testability and flexibility
- **Interface-based design**: Program to interfaces, not implementations
- **SOLID principles**: Follow Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion
- **Modularity**: Design code in small, reusable, independently testable modules
- **Clear boundaries**: Define clear boundaries between layers and components to enable parallel development
- **Incremental delivery**: Design architecture to support iterative, incremental feature delivery
- **Refactoring-friendly**: Structure code to be easily refactored as requirements evolve

These principles simplify agile development by:
- Enabling parallel work on different layers/components
- Making it easier to change requirements without ripple effects
- Facilitating test-driven development through testable components
- Supporting continuous integration and deployment
- Allowing incremental feature delivery

## API Development
- **Use FastAPI** for REST API development

## Database
- **Use PostgreSQL** as the preferred database

## Containerization
- **Docker preferred** for containerization
- **Docker Compose** for development environments

## Networking & Load Balancing
- **Use nginx** as the preferred reverse proxy and web server
- **Use Let's Encrypt** for SSL/TLS certificate management

## Async Processing & Message Queue
- **Use NATS** for message queue and async processing

## Development Environment
- **IDEs**: PyCharm and Visual Studio Code (.vscode) are preferred
- **Development setup**: Use Docker Compose for local development environments
- **IDE run configurations**: Always create run/debug configurations for both IDEs:
  - **VS Code**: Create `launch.json` in `.vscode/` for running and debugging the application
  - **PyCharm**: Create run configurations in `.idea/runConfigurations/` for running and debugging the application
  - Include configurations for:
    - Running the main application
    - Running with different environment configurations (dev, test, prod)
    - Debugging mode with appropriate breakpoint support
    - Docker Compose integration if applicable
  - Ensure configurations use the same environment variables and settings as production

## Authentication
- **Use OAuth** for authentication strategy

## Release & Versioning
- **Use semantic versioning** for all releases

## CI/CD
- **GitLab CI/CD preferred** for continuous integration and deployment
- **CI pipeline must include** (in order):
  1. Linting (ruff)
  2. Unit testing
  3. Packaging
  4. Integration testing
  5. Security scanning (bandit, ruff security rules)

## Infrastructure as Code
- **Goal: Software-defined infrastructure** - All production infrastructure should be defined, managed, and provisioned through code
- **Use Ansible** for production infrastructure management and configuration
- **Use Proxmox** as the preferred virtualization platform for production infrastructure
- **Automation authentication**: Prefer asking user for API keys/tokens to enable AI automation over remote SSH execution when possible

## Secrets Management
- **Ansible projects**: Use Ansible Vault for secrets, keep vault password in `secrets.txt` (add to .gitignore, not checked in)
- **Other projects**: Use similar approach with encrypted secrets files and password/key files excluded from version control

## Configuration Management
- **Use pydantic-settings** for environment configuration and .env file handling
- Provides type safety, validation, and multiple source support

## Logging
- **Use loguru** for logging
- Modern, easy to use, with colored output and better defaults than standard library

## Code Quality
- **Prioritize readability** unless specific performance requirements are stated
- **Use ruff** for linting and code quality checks (including security rules)
- Code should be clear and maintainable first, optimized second

## Documentation
- **Mermaid diagrams**: When creating Mermaid scripts, you **must** ensure compatibility with Microsoft DevOps (Azure DevOps) implementation
- Avoid using Mermaid features that are not supported in Azure DevOps Markdown rendering

## Security
- **Use bandit** for security vulnerability scanning
- **Use ruff** with security rules enabled
- Run security checks as part of the development workflow

## Testing Philosophy
- **Test-Driven Development (TDD)**: Always write unit tests
- **Ask before implementing**: Request information needed to write comprehensive tests before starting implementation
- Tests should be written first, then implementation to satisfy the tests

## Python Testing Setup
- **Use pytest** as the testing framework for all Python projects
- **Test directory structure**: Always create a `tests/` subfolder containing all test code
- **Pytest fixtures**: Create proper pytest fixtures in `tests/conftest.py` for reusable test components
- **Use fixtures during development**: Run tests using pytest fixtures to ensure consistent test environments
- **Manual test script**: Create a shell script (e.g., `run_tests.sh`) for manual test runs with appropriate pytest arguments
- **IDE test configurations**:
  - Create test run configurations for **VS Code** (`.vscode/settings.json`)
  - Create test run configurations for **PyCharm** (`.idea/runConfigurations/`)
  - Enable static code analysis in both IDEs as per CI pipeline requirements:
    - **ruff** for linting and code quality checks
    - **bandit** for security scanning
    - Configure IDE to run these checks automatically on save or before test runs
- **Test execution**: Ensure tests can be run both via IDE and command line with the same configuration
- **Coverage reporting**: Include pytest-cov for test coverage metrics

## GUI Application Testing
- **Full circle UI tests required** for all GUI applications
- Tests must include:
  - Button click simulation and interaction
  - Screenshot capture and verification
  - Visual regression testing where applicable
  - End-to-end user workflow validation
- Use appropriate UI testing frameworks (e.g., pytest-qt, selenium, playwright, etc.)

## Expert Agent Consultation
- **Use area-specific agents** to reason about design decisions and validate implementations
- Launch specialized agents for:
  - **Python coding expert**: Best practices, idiomatic code, performance considerations
  - **Agile developer expert**: Sprint planning, user stories, iterative development
  - **Tester expert**: Test coverage, edge cases, test strategies
  - **Architecture expert**: System design, patterns, scalability
  - **Security expert**: Vulnerability assessment, secure coding practices
  - **DevOps expert**: Deployment, CI/CD, infrastructure
- Consult agents during design phase and use them to review implementations
